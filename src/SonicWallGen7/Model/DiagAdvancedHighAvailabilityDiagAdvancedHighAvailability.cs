/*
 * SonicOS API
 *
 * __Swagger Specification for SonicOS APIs__  ___SonicOS support two-factor and bearer token login from SWAGGER only.___  Please follow the following steps to login. > 1. POST \"tfa\" with your username, password, and two-factor code to the firewall. If you are authenticating a username for the first time, please login to GUI and scan the QR code to activate two-factor authentication. > 2. The Bearer Token is returned in response to the \"tfa\" message. Copy the Bearer Token to the \"Authorize\" button. > 3. DELETE \"auth\" to logout of the current session. 
 *
 * The version of the OpenAPI document: 7.0.1
 * Contact: sonicOsApiSupport@SonicWall.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = SonicWallGen7.Client.OpenAPIDateConverter;

namespace SonicWallGen7.Model
{
    /// <summary>
    /// Configure advanced diag High Availability settings.
    /// </summary>
    [DataContract(Name = "diag_advanced_high_availability_diag_advanced_high_availability")]
    public partial class DiagAdvancedHighAvailabilityDiagAdvancedHighAvailability : IEquatable<DiagAdvancedHighAvailabilityDiagAdvancedHighAvailability>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DiagAdvancedHighAvailabilityDiagAdvancedHighAvailability" /> class.
        /// </summary>
        /// <param name="restartBackupOnWatchdog">Enable always restarting HA backup for watchdog task ..</param>
        /// <param name="interleaveCache">Enable interleave connection cache state synchronization messages..</param>
        /// <param name="cacheSyncRemoveRetryLimit">Set Connection Cache synchronization remove retry limit time..</param>
        /// <param name="cacheSyncGiveUpRemoveRetry">Set the cache usage of giving up cache remove retry..</param>
        /// <param name="recoverStatefulData">Enable HA recover stateful data when remove failed cache reaches half of maximum connection cache..</param>
        /// <param name="idleNetworkMonitorProbing">Enable network Monitor probing on Idle unit..</param>
        /// <param name="lowPacketPoolFailover">Enable HA failover when packet pool is low on active unit..</param>
        /// <param name="suppressActiveTransitionAlarm">Enable suppressing alarm on HA Transition to active..</param>
        /// <param name="multiChassisLag">Enable support for multi chassis LAG on Active/Standby noth units..</param>
        /// <param name="syslogMessagesBothUnits">Send syslog messages from both HA units with unique serial numbers..</param>
        /// <param name="maxTransparentModeGratuitousArps">Set maximum number of gratuitous ARP of transparent mode per interface while HA failover..</param>
        public DiagAdvancedHighAvailabilityDiagAdvancedHighAvailability(bool restartBackupOnWatchdog = default(bool), bool interleaveCache = default(bool), decimal cacheSyncRemoveRetryLimit = default(decimal), decimal cacheSyncGiveUpRemoveRetry = default(decimal), bool recoverStatefulData = default(bool), bool idleNetworkMonitorProbing = default(bool), bool lowPacketPoolFailover = default(bool), bool suppressActiveTransitionAlarm = default(bool), bool multiChassisLag = default(bool), bool syslogMessagesBothUnits = default(bool), decimal maxTransparentModeGratuitousArps = default(decimal))
        {
            this.RestartBackupOnWatchdog = restartBackupOnWatchdog;
            this.InterleaveCache = interleaveCache;
            this.CacheSyncRemoveRetryLimit = cacheSyncRemoveRetryLimit;
            this.CacheSyncGiveUpRemoveRetry = cacheSyncGiveUpRemoveRetry;
            this.RecoverStatefulData = recoverStatefulData;
            this.IdleNetworkMonitorProbing = idleNetworkMonitorProbing;
            this.LowPacketPoolFailover = lowPacketPoolFailover;
            this.SuppressActiveTransitionAlarm = suppressActiveTransitionAlarm;
            this.MultiChassisLag = multiChassisLag;
            this.SyslogMessagesBothUnits = syslogMessagesBothUnits;
            this.MaxTransparentModeGratuitousArps = maxTransparentModeGratuitousArps;
        }

        /// <summary>
        /// Enable always restarting HA backup for watchdog task .
        /// </summary>
        /// <value>Enable always restarting HA backup for watchdog task .</value>
        [DataMember(Name = "restart_backup_on_watchdog", EmitDefaultValue = true)]
        public bool RestartBackupOnWatchdog { get; set; }

        /// <summary>
        /// Enable interleave connection cache state synchronization messages.
        /// </summary>
        /// <value>Enable interleave connection cache state synchronization messages.</value>
        [DataMember(Name = "interleave_cache", EmitDefaultValue = true)]
        public bool InterleaveCache { get; set; }

        /// <summary>
        /// Set Connection Cache synchronization remove retry limit time.
        /// </summary>
        /// <value>Set Connection Cache synchronization remove retry limit time.</value>
        [DataMember(Name = "cache_sync_remove_retry_limit", EmitDefaultValue = false)]
        public decimal CacheSyncRemoveRetryLimit { get; set; }

        /// <summary>
        /// Set the cache usage of giving up cache remove retry.
        /// </summary>
        /// <value>Set the cache usage of giving up cache remove retry.</value>
        [DataMember(Name = "cache_sync_give_up_remove_retry", EmitDefaultValue = false)]
        public decimal CacheSyncGiveUpRemoveRetry { get; set; }

        /// <summary>
        /// Enable HA recover stateful data when remove failed cache reaches half of maximum connection cache.
        /// </summary>
        /// <value>Enable HA recover stateful data when remove failed cache reaches half of maximum connection cache.</value>
        [DataMember(Name = "recover_stateful_data", EmitDefaultValue = true)]
        public bool RecoverStatefulData { get; set; }

        /// <summary>
        /// Enable network Monitor probing on Idle unit.
        /// </summary>
        /// <value>Enable network Monitor probing on Idle unit.</value>
        [DataMember(Name = "idle_network_monitor_probing", EmitDefaultValue = true)]
        public bool IdleNetworkMonitorProbing { get; set; }

        /// <summary>
        /// Enable HA failover when packet pool is low on active unit.
        /// </summary>
        /// <value>Enable HA failover when packet pool is low on active unit.</value>
        [DataMember(Name = "low_packet_pool_failover", EmitDefaultValue = true)]
        public bool LowPacketPoolFailover { get; set; }

        /// <summary>
        /// Enable suppressing alarm on HA Transition to active.
        /// </summary>
        /// <value>Enable suppressing alarm on HA Transition to active.</value>
        [DataMember(Name = "suppress_active_transition_alarm", EmitDefaultValue = true)]
        public bool SuppressActiveTransitionAlarm { get; set; }

        /// <summary>
        /// Enable support for multi chassis LAG on Active/Standby noth units.
        /// </summary>
        /// <value>Enable support for multi chassis LAG on Active/Standby noth units.</value>
        [DataMember(Name = "multi_chassis_lag", EmitDefaultValue = true)]
        public bool MultiChassisLag { get; set; }

        /// <summary>
        /// Send syslog messages from both HA units with unique serial numbers.
        /// </summary>
        /// <value>Send syslog messages from both HA units with unique serial numbers.</value>
        [DataMember(Name = "syslog_messages_both_units", EmitDefaultValue = true)]
        public bool SyslogMessagesBothUnits { get; set; }

        /// <summary>
        /// Set maximum number of gratuitous ARP of transparent mode per interface while HA failover.
        /// </summary>
        /// <value>Set maximum number of gratuitous ARP of transparent mode per interface while HA failover.</value>
        [DataMember(Name = "max_transparent_mode_gratuitous_arps", EmitDefaultValue = false)]
        public decimal MaxTransparentModeGratuitousArps { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class DiagAdvancedHighAvailabilityDiagAdvancedHighAvailability {\n");
            sb.Append("  RestartBackupOnWatchdog: ").Append(RestartBackupOnWatchdog).Append("\n");
            sb.Append("  InterleaveCache: ").Append(InterleaveCache).Append("\n");
            sb.Append("  CacheSyncRemoveRetryLimit: ").Append(CacheSyncRemoveRetryLimit).Append("\n");
            sb.Append("  CacheSyncGiveUpRemoveRetry: ").Append(CacheSyncGiveUpRemoveRetry).Append("\n");
            sb.Append("  RecoverStatefulData: ").Append(RecoverStatefulData).Append("\n");
            sb.Append("  IdleNetworkMonitorProbing: ").Append(IdleNetworkMonitorProbing).Append("\n");
            sb.Append("  LowPacketPoolFailover: ").Append(LowPacketPoolFailover).Append("\n");
            sb.Append("  SuppressActiveTransitionAlarm: ").Append(SuppressActiveTransitionAlarm).Append("\n");
            sb.Append("  MultiChassisLag: ").Append(MultiChassisLag).Append("\n");
            sb.Append("  SyslogMessagesBothUnits: ").Append(SyslogMessagesBothUnits).Append("\n");
            sb.Append("  MaxTransparentModeGratuitousArps: ").Append(MaxTransparentModeGratuitousArps).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DiagAdvancedHighAvailabilityDiagAdvancedHighAvailability);
        }

        /// <summary>
        /// Returns true if DiagAdvancedHighAvailabilityDiagAdvancedHighAvailability instances are equal
        /// </summary>
        /// <param name="input">Instance of DiagAdvancedHighAvailabilityDiagAdvancedHighAvailability to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DiagAdvancedHighAvailabilityDiagAdvancedHighAvailability input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.RestartBackupOnWatchdog == input.RestartBackupOnWatchdog ||
                    this.RestartBackupOnWatchdog.Equals(input.RestartBackupOnWatchdog)
                ) && 
                (
                    this.InterleaveCache == input.InterleaveCache ||
                    this.InterleaveCache.Equals(input.InterleaveCache)
                ) && 
                (
                    this.CacheSyncRemoveRetryLimit == input.CacheSyncRemoveRetryLimit ||
                    this.CacheSyncRemoveRetryLimit.Equals(input.CacheSyncRemoveRetryLimit)
                ) && 
                (
                    this.CacheSyncGiveUpRemoveRetry == input.CacheSyncGiveUpRemoveRetry ||
                    this.CacheSyncGiveUpRemoveRetry.Equals(input.CacheSyncGiveUpRemoveRetry)
                ) && 
                (
                    this.RecoverStatefulData == input.RecoverStatefulData ||
                    this.RecoverStatefulData.Equals(input.RecoverStatefulData)
                ) && 
                (
                    this.IdleNetworkMonitorProbing == input.IdleNetworkMonitorProbing ||
                    this.IdleNetworkMonitorProbing.Equals(input.IdleNetworkMonitorProbing)
                ) && 
                (
                    this.LowPacketPoolFailover == input.LowPacketPoolFailover ||
                    this.LowPacketPoolFailover.Equals(input.LowPacketPoolFailover)
                ) && 
                (
                    this.SuppressActiveTransitionAlarm == input.SuppressActiveTransitionAlarm ||
                    this.SuppressActiveTransitionAlarm.Equals(input.SuppressActiveTransitionAlarm)
                ) && 
                (
                    this.MultiChassisLag == input.MultiChassisLag ||
                    this.MultiChassisLag.Equals(input.MultiChassisLag)
                ) && 
                (
                    this.SyslogMessagesBothUnits == input.SyslogMessagesBothUnits ||
                    this.SyslogMessagesBothUnits.Equals(input.SyslogMessagesBothUnits)
                ) && 
                (
                    this.MaxTransparentModeGratuitousArps == input.MaxTransparentModeGratuitousArps ||
                    this.MaxTransparentModeGratuitousArps.Equals(input.MaxTransparentModeGratuitousArps)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.RestartBackupOnWatchdog.GetHashCode();
                hashCode = (hashCode * 59) + this.InterleaveCache.GetHashCode();
                hashCode = (hashCode * 59) + this.CacheSyncRemoveRetryLimit.GetHashCode();
                hashCode = (hashCode * 59) + this.CacheSyncGiveUpRemoveRetry.GetHashCode();
                hashCode = (hashCode * 59) + this.RecoverStatefulData.GetHashCode();
                hashCode = (hashCode * 59) + this.IdleNetworkMonitorProbing.GetHashCode();
                hashCode = (hashCode * 59) + this.LowPacketPoolFailover.GetHashCode();
                hashCode = (hashCode * 59) + this.SuppressActiveTransitionAlarm.GetHashCode();
                hashCode = (hashCode * 59) + this.MultiChassisLag.GetHashCode();
                hashCode = (hashCode * 59) + this.SyslogMessagesBothUnits.GetHashCode();
                hashCode = (hashCode * 59) + this.MaxTransparentModeGratuitousArps.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
